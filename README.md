# conveyor
1. Инициализировать Spring-Boot приложение conveyor, добавить в github
Добавить проект в *github*, отвести от ветки main ветку *develop*.
Рекомендуемая структура папок: *<папка_с_полным_именем_проекта>/<папка_с_МС>*
Все дальнейшие изменения производить из веток, отведенных от develop через *pull request* в *develop*.
Имена этих веток формируются следующим образом:*<feature/bugfix>/<MS-name>/<1-3_слова_характирезующие изменения>*
Эти правила стоит соблюдать для всех следующих микросервисов.

2. Определить DTO (описание всех DTO):
  * *LoanApplicationRequestDTO*
  * *LoanOfferDTO*
  * *ScoringDataDTO*
  * *CreditDTO*
  * *EmploymentDTO*
  * *PaymentScheduleElement*

3. Определить API:
  * *POST: /conveyor/offers* - расчёт возможных условий кредита.
    *Request - LoanApplicationRequestDTO, response - List<LoanOfferDTO>*

  * *POST: /conveyor/calculation* - валидация присланных данных + скоринг данных + полный расчет параметров кредита.
    *Request - ScoringDataDTO, response CreditDTO*.

4. Реализовать логику работы API:
  * *POST: /conveyor/offers*
  1. По API приходит *LoanApplicationRequestDTO*.
  2. На основании *LoanApplicationRequestDTO* происходит прескоринг создаётся 4 кредитных предложения
     LoanOfferDTO на основании всех возможных комбинаций булевских полей *isInsuranceEnabled* и
     *isSalaryClient (false-false, false-true, true-false, true-true)*. Логику формирования кредитных предложений
     можно придумать самому. К примеру: в зависимости от страховых услуг увеличивается/уменьшается процентная ставка
     и сумма кредита, базовая ставка хардкодится в коде через property файл. Например цена страховки 100к
     (или прогрессивная, в зависимости от запрошенной суммы кредита), ее стоимость добавляется в тело кредита,
     но она уменьшает ставку на 3. Цена зарплатного клиента 0, уменьшает ставку на 1.
  3. Ответ на API - список из 4х *LoanOfferDTO* от "худшего" к "лучшему" (чем меньше итоговая ставка, тем лучше).
  * *POST: /conveyor/calculation*
  1. По API приходит *ScoringDataDTO*.
  2. Происходит скоринг данных, высчитывание ставки(rate), полной стоимости кредита(psk),
     размер ежемесячного платежа(*monthlyPayment*),
     график ежемесячных платежей (*List<PaymentScheduleElement>*). Логику расчета параметров кредита
     можно найти в интернете, полученный результат сверять с имеющимися в интернете калькуляторами графиков платежей и ПСК.
  3. Ответ на API - *CreditDTO*, насыщенный всеми рассчитанными параметрами.

5. Покрыть логику всю логику микросервиса логгированием, задокументировать API через *Swagger*
   Залоггировать входные данные, промежуточные шаги и конечный результат.
   Добавлена документация всех API через Swagger (см. springdoc).

6. Покрыть логику всю логику микросервиса unit-тестами
   Процент покрытия тестами всего микросервиса 90%. Для создание заглушек здесь и далее использовать библиотеку *Mockito*